{
  "TypeScript Arrow Function": {
    "prefix": "etsf",
    "body": [
      "export const ${1:functionName} = (${2:params}): ${3:ReturnType} => {",
      "\t${4:// Implementation}",
      "\treturn ${5:result};",
      "};",
    ],
    "description": "Create a TypeScript function",
  },
  "Zod Schema": {
    "prefix": "zod",
    "body": [
      "import { z } from 'zod';",
      "",
      "export const ${1:schemaName}Schema = z.object({",
      "\t${2:property}: z.${3:string}(),",
      "});",
      "",
      "export type ${1:schemaName} = z.infer<typeof ${1:schemaName}Schema>;",
    ],
    "description": "Create a Zod schema with TypeScript type",
  },
  "Zod variable": {
    "prefix": "zodvar",
    "body": [
      "export const ${1:varName}Schema = z.object({});",
      "\t",
      "export type ${1:varName} = z.infer<typeof ${1:varName}Schema>;",
    ],
    "description": "Create a Zod variable",
  },
  "Export TypeScript Interface": {
    "prefix": "tsi",
    "body": ["export interface ${1:InterfaceName} {", "\t${2:property}: ${3:type};", "}"],
    "description": "Create a TypeScript interface",
  },
  "Export TypeScript Type": {
    "prefix": "etst",
    "body": ["export type ${1:TypeName} = ${2:type};"],
    "description": "Create a TypeScript type",
  },
  "Async Try-Catch": {
    "prefix": "tryc",
    "body": [
      "try {",
      "} catch (error) {",
      "\tconsole.error('Error in ${2:function}:', error);",
      "\t${3:// Error handling}",
      "}",
    ],
    "description": "Create a try-catch block for async operations",
  },
  "Console Log with Context": {
    "prefix": "clog",
    "body": ["console.log('${1:context}:', JSON.stringify(${2:data}, null, 2));"],
    "description": "Console log with context and formatted JSON",
  },
  "Declare Expororting Async function": {
    "prefix": "edaf",
    "body": [
      "export async function ${1:functionName}(${2:params}): Promise<${3:ReturnType}> {",
      "\t${4:// Implementation}",
      "\treturn {};",
      "}",
    ],
    "description": "Declare an async function with Promise return type",
  },
  "Declare Exporting Function": {
    "prefix": "edf",
    "body": ["export function ${1:functionName}(${2:params}): ${3:ReturnType} {", "\treturn {};", "}"],
    "description": "Declare a function with return type",
  },

  "AWS Lambda Imports": {
    "prefix": "lambdaimp",
    "body": ["import { createApiGatewayFunction, CustomError, extractMetadata } from '@/libs';"],
    "description": "Import necessary modules for AWS Lambda",
  },
  "AWS Lambda Handler": {
    "prefix": "lambda-api",
    "body": [
      "",
      "export const ${3:handlerName} = createApiGatewayFunction(async (event) => {",
      "\t${4:// Implementation}",
      "\treturn await ${1:serviceName}Service();",
      "});",
    ],
    "description": "Create an AWS Lambda handler with createApiGatewayFunction",
  },
  "AWS Lambda With Path variable": {
    "prefix": "lambdapath",
    "body": [
      "export const get${3:EntityName}ById = createApiGatewayFunction(async (event) => {",
      "\tconst { pathParams } = extractMetadata(event);",
      "\tif (!pathParams || !pathParams.id) throw new CustomError('Path param id is missing!');",
      "",
      "\treturn await ${1:serviceName}Service(pathParams.id);",
      "});",
    ],
    "description": "Create a Lambda handler with path variable",
  },
  "Lambda Query": {
    "prefix": "lambdaquery",
    "body": [
      "export const get${3:EntityName}sByQuery = createApiGatewayFunction(async (event) => {",
      "\tconst { queryParams } = extractMetadata(event);",
      "\tif (!queryParams) throw new CustomError('Query params are missing!');",
      "",
      "\tconst parseResult = QueryRequestSchema.safeParse({ indexName: queryParams.index, ...queryParams });",
      "",
      "\tif (!parseResult.success) {",
      "\t\tconst validationErrors = parseResult.error.issues.map((err) => err.path.join('.')).join(', ');",
      "\t\tthrow new CustomError(`Query params are missing!, \\${validationErrors}`);",
      "\t}",
      "});",
    ],
    "description": "Create a Lambda handler for query operations",
  },
  "Dynamo Service Get Functions": {
    "prefix": "dynamo-srv-get",
    "body": [
      "import type { OptPartial${1:EntityName}, Queried${1:EntityName}s } from '@/repository/${2:entityName}';",
      "import {",
      "\tget${1:EntityName}ById as get${1:EntityName}ByIdRepo,",
      "\tget${1:EntityName}sByQuery as get${1:EntityName}sByQueryRepo,",
      "\tget${1:EntityName}TableDescription",
      "} from '@/repository/${1:entityName}';",
      "import type { DescribeTableCommandOutput, QueryRequest as Query } from '@/libs/dynamo';",
      "",
      "export async function get${1:EntityName}TableDesc(): Promise<DescribeTableCommandOutput> {",
      "\treturn await get${1:EntityName}TableDescription();",
      "}",
      "",
      "export async function get${1:EntityName}ById(id: string, proj?: string): Promise<OptPartial${1:EntityName}> {",
      "\treturn await get${1:EntityName}ByIdRepo(id, proj);",
      "}",
      "",
      "export async function get${1:EntityName}sByQuery(query: Query, proj?: string): Promise<Queried${1:EntityName}s> {",
      "\treturn await get${1:EntityName}sByQueryRepo(query, proj);",
      "}",
    ],
  },
  "Dynamo Service Create Function": {
    "prefix": "dynamo-srv-create",
    "body": [
      "import type { ${1:EntityName} } from '@/@types/';",
      "import { create${1:EntityName} as create${1:EntityName}Repo } from '@/repository/repo';",
      "",
      "export async function create${1:EntityName}(newItem: ${1:EntityName}): Promise<${1:EntityName}> {",
      "\treturn await create${1:EntityName}Repo(newItem);",
      "}",
    ],
  },
  "Dynamo Service Update Function": {
    "prefix": "dynamo-srv-update",
    "body": [
      "import type { ${1:EntityName} } from '@/@types/';",
      "import { update${1:EntityName} as update${1:EntityName}Repo } from '@/repository/';",
      "import { CustomError } from '@/libs/error';",
      "import { get${1:EntityName}ById } from './';",
      "",
      "export async function update${1:EntityName}(id: string, update: object): Promise<${1:EntityName}> {",
      "\tconst item = (await get${1:EntityName}ById(id)) as ${1:EntityName};",
      "\tif (!item) throw new CustomError(`Item with id: ${id} not found`, 404);",
      "",
      "\treturn await update${1:EntityName}Repo({ ...update, ...item } as ${1:EntityName});",
      "}",
    ],
  },
  "DynamoDB Repository": {
    "prefix": "dynamo",
    "body": [
      "import type { ${1:ExampleItem} } from '@/types';",
      "import { ${2:exampleItem}Sch } from '@/types';",
      "import { omit } from '@/libs/utility';",
      "import { DescribeTableCommandOutput } from '@aws-sdk/client-dynamodb';",
      "import { DynamoQueryRequest } from '../dynamo';",
      "import {",
      "\tcreateRecordOnDynamo,",
      "\tgetRecordFromDynamo,",
      "\tgetTableDescFromDynamo,",
      "\tqueryRecordFromDynamo,",
      "\tupdateRecordOnDynamo,",
      "} from './dynamo-client';",
      "",
      "export type QueryOutput<T> = { items: T[]; lastEvaluatedKey?: Record<string, unknown> };",
      "export type Queried${1:ExampleItem}s = QueryOutput<Prt${1:ExampleItem}>;",
      "export type Prt${1:ExampleItem} = Partial<${1:ExampleItem}>;",
      "export type OptPartial${1:ExampleItem} = Partial<${1:ExampleItem}> | undefined;",
      "export type Optional${1:ExampleItem} = ${1:ExampleItem} | undefined;",
      "type ExtraType = Record<string, unknown>;",
      "",
      "const TABLE_NAME = '${3:example-item-table}';",
      "",
      "/**",
      " * Retrieves the description of the ${1:ExampleItem} table from DynamoDB.",
      " * @returns The description of the ${1:ExampleItem} table.",
      " */",
      "async function get${1:ExampleItem}TableDescription(): Promise<DescribeTableCommandOutput> {",
      "\treturn await getTableDescFromDynamo(TABLE_NAME);",
      "}",
      "",
      "/**",
      " * Retrieves an ${1:ExampleItem} from DynamoDB by its ID.",
      " *",
      " * @param id - The ID of the ${1:ExampleItem} to retrieve.",
      " * @param proj - Optional projection expression to specify which attributes to retrieve.",
      " * @returns The ${1:ExampleItem} if found, otherwise undefined.",
      " */",
      "async function get${1:ExampleItem}ById(id: string, proj?: string): Promise<OptPartial${1:ExampleItem}> {",
      "\tconst params = {",
      "\t\ttableName: TABLE_NAME,",
      "\t\tkey: { id },",
      "\t\tprojectionExpression: proj,",
      "\t};",
      "",
      "\tconst { Item } = await getRecordFromDynamo(params);",
      "\treturn Item ? (Item as ${1:ExampleItem} | Partial<${1:ExampleItem}>) : undefined;",
      "}",
      "",
      "/**",
      " * Retrieves ${1:ExampleItem}s from DynamoDB based on the provided query conditions.",
      " *",
      " * @param query - The query conditions to filter the ${1:ExampleItem}s.",
      " * @param proj - Optional projection expression to specify which attributes to retrieve.",
      " * @returns The queried ${1:ExampleItem}s along with the last evaluated key for pagination.",
      " */",
      "async function get${1:ExampleItem}sByQuery(query: DynamoQueryRequest, proj?: string): Promise<Queried${1:ExampleItem}s> {",
      "\tconst { Items, LastEvaluatedKey } = await queryRecordFromDynamo({",
      "\t\ttableName: TABLE_NAME,",
      "\t\tqueryRequest: query,",
      "\t\tprojectionExpression: proj,",
      "\t});",
      "",
      "\treturn {",
      "\t\titems: Items ? (Items as ${1:ExampleItem}[] | Partial<${1:ExampleItem}>[]) : [],",
      "\t\tlastEvaluatedKey: LastEvaluatedKey ?? {},",
      "\t};",
      "}",
      "",
      "/**",
      " * Creates a new ${1:ExampleItem} in DynamoDB.",
      " *",
      " * @param newItem - The ${1:ExampleItem} to be created.",
      " * @returns The created ${1:ExampleItem} with all attributes as stored in DynamoDB.",
      " */",
      "async function create${1:ExampleItem}(newItem: ${1:ExampleItem}): Promise<${1:ExampleItem}> {",
      "\tconst { Attributes } = await createRecordOnDynamo({",
      "\t\ttableName: TABLE_NAME,",
      "\t\titem: newItem,",
      "\t\treturnValues: 'ALL_NEW',",
      "\t});",
      "\treturn ${2:exampleItem}Sch.parse(Attributes);",
      "}",
      "",
      "/**",
      " * Updates an existing ${1:ExampleItem} in DynamoDB directly.",
      " *",
      " * @param item - The ${1:ExampleItem} to be updated.",
      " * @param con - Optional condition expression to ensure the update only occurs if certain conditions are met.",
      " * @param ext - Optional extra expression attribute values for the update operation.",
      " * @returns The updated ${1:ExampleItem}.",
      " */",
      "async function update${1:ExampleItem}Directly(item: Prt${1:ExampleItem}, con?: string, ext?: ExtraType): Promise<Prt${1:ExampleItem}> {",
      "\tawait updateRecordOnDynamo({",
      "\t\ttableName: TABLE_NAME,",
      "\t\tkey: { id: item.id },",
      "\t\titem: omit(item, ['id']),",
      "\t\tconditionExpression: con,",
      "\t\textraExpAttributeValues: ext,",
      "\t\treturnValues: 'NONE',",
      "\t});",
      "\treturn await item;",
      "}",
      "",
      "/**",
      " * Updates an existing ${1:example item} in DynamoDB using an update expression.",
      " *",
      " * @param id  - The ID of the ${1:example item} to be updated.",
      " * @param updateExp - The update expression specifying the attributes to be updated.",
      " * @param con - Optional condition expression to ensure the update only occurs if certain conditions are met.",
      " * @param ext - Optional extra expression attribute values for the update operation.",
      " */",
      "async function update${1:ExampleItem}ByExpression(",
      "\tid: string,",
      "\tupdateExp: string,",
      "\tcon?: string,",
      "\text?: ExtraType",
      "): Promise<void> {",
      "\tawait updateRecordOnDynamo({",
      "\t\ttableName: TABLE_NAME,",
      "\t\tkey: { id },",
      "\t\tupdateExpression: updateExp,",
      "\t\tconditionExpression: con,",
      "\t\textraExpAttributeValues: ext,",
      "\t\treturnValues: 'NONE',",
      "\t});",
      "}",
      "",
      "export {",
      "\tcreate${1:ExampleItem},",
      "\tget${1:ExampleItem}ById,",
      "\tget${1:ExampleItem}sByQuery,",
      "\tget${1:ExampleItem}TableDescription,",
      "\tupdate${1:ExampleItem}ByExpression,",
      "\tupdate${1:ExampleItem}Directly,",
      "};",
    ],
    "description": "Complete DynamoDB repository with CRUD operations and query support",
  },
  "DynamoDB Root Client Functions": {
    "prefix": "dynamo-root",
    "body": [
      "import { DescribeTableCommand, DescribeTableCommandOutput, DynamoDBClient } from '@aws-sdk/client-dynamodb';",
      "import {",
      "\tDynamoDBDocumentClient,",
      "\tGetCommand,",
      "\tGetCommandOutput,",
      "\tPutCommand,",
      "\tPutCommandOutput,",
      "\tQueryCommand,",
      "\tQueryCommandOutput,",
      "\tUpdateCommand,",
      "} from '@aws-sdk/lib-dynamodb';",
      "import {",
      "\tbuildGetCommandInput,",
      "\tbuildPutCommandInput,",
      "\tbuildQueryCommandInput,",
      "\tbuildUpdateCommandInput,",
      "\tCustomGetCommandInput,",
      "\tCustomPutCommandInput,",
      "\tCustomQueryCommandInput,",
      "\tCustomUpdateCommandInput,",
      "} from '../dynamo';",
      "import { logger } from '../libs';",
      "",
      "const dynamoDb = new DynamoDBClient({ region: process.env.AWS_REGION || 'ap-southeast-1' });",
      "const docClient = DynamoDBDocumentClient.from(dynamoDb);",
      "",
      "/**",
      " * Retrieves the description and metadata of a DynamoDB table.",
      " *",
      " * @param tableName - The name of the DynamoDB table to describe",
      " * @returns {Promise<DescribeTableCommandOutput>} table description output",
      " * @throws Error if the table description retrieval fails",
      " */",
      "export async function getTableDescFromDynamo(tableName: string): Promise<DescribeTableCommandOutput> {",
      "\ttry {",
      "\t\treturn await docClient.send(new DescribeTableCommand({ TableName: tableName }));",
      "\t} catch (error) {",
      "\t\tlogger.error(`Failed to retrieve table description for \"${tableName}\":`, error);",
      "\t\tthrow error;",
      "\t}",
      "}",
      "",
      "/**",
      " * Retrieves a single record from DynamoDB using the Document Client.",
      " *",
      " * @param input - The get command input containing the table name, key, and optional projection expression",
      " * @returns {Promise<GetCommandOutput>} get command output containing the retrieved item",
      " * @throws Error if the record retrieval fails",
      " */",
      "export async function getRecordFromDynamo(input: CustomGetCommandInput): Promise<GetCommandOutput> {",
      "\ttry {",
      "\t\tconst buildCommand = buildGetCommandInput(input);",
      "\t\treturn await docClient.send(new GetCommand(buildCommand));",
      "\t} catch (error: unknown) {",
      "\t\tlogger.error('Error retrieving record from DynamoDB:', error);",
      "\t\tthrow error;",
      "\t}",
      "}",
      "",
      "/**",
      " * Queries records from DynamoDB based on partition key and optional sort key conditions.",
      " *",
      " * @param input - The query command input containing table name, key conditions, filter expressions, and projection settings",
      " * @returns {Promise<QueryCommandOutput>} query command output containing matching items and pagination information",
      " * @throws Error if the query operation fails",
      " */",
      "export async function queryRecordFromDynamo(input: CustomQueryCommandInput): Promise<QueryCommandOutput> {",
      "\ttry {",
      "\t\tconst buildCommand = buildQueryCommandInput(input);",
      "\t\treturn await docClient.send(new QueryCommand(buildCommand));",
      "\t} catch (error: unknown) {",
      "\t\tlogger.error('Error querying records from DynamoDB:', error);",
      "\t\tthrow error;",
      "\t}",
      "}",
      "",
      "/**",
      " * Creates a new record in DynamoDB using the PutCommand.",
      " *",
      " * @param input - The put command input containing the table name, item data, and optional condition expressions",
      " * @returns {Promise<PutCommandOutput>} put command output containing the result of the put operation",
      " * @throws Error if the record creation fails (e.g., condition expression not met or validation errors)",
      " */",
      "export async function createRecordOnDynamo(input: CustomPutCommandInput): Promise<PutCommandOutput> {",
      "\ttry {",
      "\t\tconst buildCommand = buildPutCommandInput(input);",
      "\t\treturn await docClient.send(new PutCommand(buildCommand));",
      "\t} catch (error: unknown) {",
      "\t\tlogger.error('Error creating record in DynamoDB:', error);",
      "\t\tthrow error;",
      "\t}",
      "}",
      "",
      "/**",
      " * Updates an existing record in DynamoDB using the PutCommand.",
      " * Note: This performs a full item replacement. For partial updates, consider using UpdateCommand.",
      " *",
      " * @param input - The put command input containing the table name, item data, and optional condition expressions",
      " * @returns {Promise<PutCommandOutput>} put command output containing the result of the put operation",
      " * @throws Error if the record update fails (e.g., condition expression not met or validation errors)",
      " */",
      "export async function updateRecordOnDynamo(input: CustomUpdateCommandInput): Promise<PutCommandOutput> {",
      "\ttry {",
      "\t\tconst updateCommand = buildUpdateCommandInput(input);",
      "\t\treturn await docClient.send(new UpdateCommand(updateCommand));",
      "\t} catch (error: unknown) {",
      "\t\tlogger.error('Error updating record in DynamoDB:', error);",
      "\t\tthrow error;",
      "\t}",
      "}",
    ],
    "description": "Complete DynamoDB root client with all CRUD operations",
  },
}
